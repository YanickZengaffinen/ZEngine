using System;
using System.Collections.Generic;
using System.Text;

namespace ZEngine.Common.UID.StdImpl
{
    /// <summary>
    /// Support for up to <see cref="Int32.MaxValue"/> unique IDs.
    /// 
    /// They are not chosen randomly but incrementally!
    /// Uniqueness guaranteed.
    /// </summary>
    public class UIDManager
    {
        private int currentId = int.MinValue;
        private List<int> usedIDs = new List<int>(); //sorted list of all IDs currently in use
        private Stack<int> freeIDs = new Stack<int>(); //ids that have been freed up

        /// <summary>
        /// Frees up an ID
        /// </summary>
        /// <returns></returns>
        public void Free(int id)
        {
            freeIDs.Push(id);

            int index = usedIDs.BinarySearch(id);
            if (index >= 0)
            {
                usedIDs.RemoveAt(index);
            }
        }

        /// <summary>
        /// Blocks an id so it can no longer be generated by this manager
        /// Only works in safemode or with non scattered IDs
        /// </summary>
        /// <param name="id"></param>
        /// <returns>False if the ID is already blocked</returns>
        public bool Block(int id)
        {
            int index = usedIDs.BinarySearch(id);
            if (index < 0)
            {
                usedIDs.Insert(~index, id);
                currentId = Math.Max(currentId, id);
                return true;
            }

            return false;
        }

        /// <summary>
        /// Generates a unique id
        /// </summary>
        /// <returns></returns>
        public int Generate()
        {
            if(freeIDs.Count > 0)
            {
                return freeIDs.Pop();
            }

            int startId = currentId;
            int index = -1;
            do
            {
                currentId = (currentId == int.MaxValue ? int.MinValue : currentId) + 1;
            } while ((index = usedIDs.BinarySearch(currentId)) >= 0 && currentId != startId);

            usedIDs.Insert(~index, currentId);

            return currentId;
        }

    }
}
